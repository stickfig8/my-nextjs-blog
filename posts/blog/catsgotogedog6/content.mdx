---
title: 어디가냥? 같이가개! 제작기 (6)
date: "2025-08-03"
desc: React 팀 프로젝트 6탄 (Union Type)
tags: ["CatsGoTogedog", "typescript", "type", "union", "file"]
---

## 1. 문제 발생
### -자료형에 대한 문제
&nbsp;현재 프로젝트에는 리뷰 작성 기능과 리뷰 조회, 수정 기능이 존재합니다. 리뷰 작성 시에는 이미지파일(jpg, png 등)을 첨부 할 수 있는데, 사진을 첨부하면 ==File==자료형을 `Props`로 받아 프리뷰 카드를 제공합니다.

![리뷰 사진 카드](/postImgs/blog/catsgotogedog6/1.png)

해당 카드에 대한 코드는 아래와 같습니다.
> /components/reviewWritePage/AttatchedPhotoCard.tsx
```ts
import MainCard from "../mainPage/MainCard";

interface Props {
  onXClick: () => void;
  img: File;
}

const AttatchedPhotoCard = ({ img, onXClick }: Props) => {
  const imageUrl = URL.createObjectURL(img);
  return (
    <div className="w-[212px] h-[141px] relative">
      <MainCard className={`w-full h-full`}>
        <img
          src={imageUrl ?? "/assets/images/common/default_thumbnail.png"}
          className="w-full h-full object-cover object-center"
        />
      </MainCard>
      <button
        className="absolute top-[11px] left-[171px] w-[24px] h-[24px] cursor-pointer"
        onClick={onXClick}
      >
        <img
          className="w-full h-full"
          src="/assets/buttons/modal_close.png"
          alt="close button"
        />
      </button>
    </div>
  );
};

export default AttatchedPhotoCard;
```

문제는 수정에서 발생합니다.

리뷰 수정은 기존 리뷰의 내용을 가져오기 때문에 기존 리뷰의 사진 또한 불러오게 됩니다. 여기서 받은 사진은 작성시에 첨부하는 자료형과 다르게 ==url==형식으로 전달 받게 됩니다.

기존의 `AttatchedPhotoCard`는 `File`자료형을 ==Props==로 받기 때문에 `string`형식의 ==url== 데이터에 대응이 되지 않습니다. 또한 다시 수정 API 호출을 하게 될 때는 ==request body==에 기존의 파일(url)이 아닌 새로운 `File`자료형만 보낼 수 있게끔 API가 구성되어 있어 서로 다른 자료형에 맞추어 사진 프리뷰가 제공되어야 했습니다.

처음 고안해낸 아이디어는 기존의 ==url==의 이미지를 다운로드 받아 `File`객체로 변환하는 방식이였으나, 이는 효율성의 문제와 ==COR== 정책에 위배되는 리스크가 존재하였습니다.

이를 효과적으로 해결하기 위해 구현한 아이디어는 ==Union Type==이였습니다.

***

## 2. Union Type
### -Union Type이란
&nbsp;==Union Type==는 ==js==의 ==OR 연산자==를 이용하여 하나의 자료형에 여러가지 자료형을 할당하여 여러 타입 중 하나가 될 수 있는 값을 정의할 때 사용합니다. 

예를 들어

```ts
type union = string | number;
```
와 같이 사용하면 `union` 타입은 `string` 혹은 `number`타입일 수 있게 되는 것입니다. 자료형을 중시하는 ==ts==특성 상 오남용하게 되면 위험할 수 있지만, 유연한 타입지정을 할 때 효과적으로 사용할 수 있습니다.

### -사용
&nbsp;앞서 설명한 ==Union Type==을 프로젝트에 적용해보겠습니다.
> /types/apiResponseTypes.ts
```ts
type ResponseImage = {
  imageId: number;
  imageUrl: string;
};
```
> /types/forFrontTypes.ts
```ts
type MixedImage = File | ResponseImage;
```

위와 같이 타입을 선언하였고,

>
```ts
import type { MixedImage } from "@/types/forFrontTypes";
import MainCard from "../mainPage/MainCard";
import { isResponseImage } from "@/lib/reviewWriteUtils";

interface Props {
  onXClick: () => void;
  img: MixedImage;
}

const AttatchedEditPhotoCard = ({ img, onXClick }: Props) => {
  const imageUrl = isResponseImage(img)
    ? img.imageUrl
    : URL.createObjectURL(img);
  return (
    <div className="w-[212px] h-[141px] relative">
      <MainCard className={`w-full h-full`}>
        <img
          src={imageUrl ?? "/assets/images/common/default_thumbnail.png"}
          className="w-full h-full object-cover object-center"
        />
      </MainCard>
      ...
```
위와 같이 사용하여 ==Props==로 들어온 `img`가 `File`인지 `ResponseImage`인지 판별하여 이미지를 세팅해주었습니다.


### -관리와 요청
&nbsp;첨부 이미지는 총 세장이기 때문에 배열 형식으로 저장됩니다. 각 요소의 실질적 자료형이 상이할 수 있으므로, 각 요소가 제거될 경우 유의가 필요했습니다. 
> /hooks/useReviewEdit.ts
```ts
...

const [images, setImages] = useState<MixedImage[]>([]); // 배열 형태 useState

...

  const removeImageByIndex = async (i: number) => {
    const target = images[i];

    if (isResponseImage(target)) {
      // 현재 인덱스의 이미지가 ResponseImage 자료형이라면
      try { // 리뷰 내 이미지 삭제 요청
        const res = await fetchWithAuth(
          `/api/review/${id}/image/${target.imageId}`,
          { method: "DELETE" }
        );

        if (!res.ok) {
          throw new Error("이미지 삭제 api 요청 실패");
        }

        setImages((prev) => prev.filter((_, idx) => idx !== i));
      } catch (e) {
        console.error("이미지 삭제 실패");
      }
    } else { // 현재 인덱스의 이미지가 File 자료형이라면
      setImages((prev) => prev.filter((_, idx) => idx !== i)); // 단순 제거
    }
  };
  ...
```

구축된 API 중에 리뷰 이미지 삭제 API가 있었기 때문에, 리뷰 수정시에 이미지 카드의 X를 누르게 되면 해당 이미지의 자료형을 파악하여 기존 이미지일 경우 삭제요청을, 아직 백엔드에 전달되지 않은 신규 이미지일 경우 배열에서 삭제하는 형태로 구현했습니다.

역으로 수정 요청을 넣을 때는 배열에 있는 자료형중 `File`만 판별하여 요청하는 형태로 구현하였습니다.

이러한 방식들을 이용하여 원활히 리뷰 수정 기능을 구현하였습니다.
*** 

## 3. 마치며
&nbsp;이번 게시물에서는 ==Union Type==을 통해 동시에 여러 자료형이 필요한 상황에 대응하는 방법에 대해 알아보았습니다. 혹시 궁금한 점이나 피드백이 있으시면 댓글 남겨주세요