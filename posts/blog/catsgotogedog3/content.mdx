---
title: 어디가냥? 같이가개! 제작기 (3)
date: "2025-07-20"
desc: React 팀 프로젝트 3탄 (JWT 기반 로그인 시스템)
tags: ["CatsGoTogedog", "JWT", "auth", "social_login", "secure", "zustand"]
---

## 1. 로그인 시스템
### -로그인 시스템 협의
&nbsp;회원 단계의 서비스도 제공하고 있기 때문에 프로젝트 내의 인증 시스템이 필요하였습니다. 백엔드와의 협의를 통해 소셜 로그인 기능만을 구현 하기로 했으며, 보안을 위해 백엔드 주도 방식의 인증 형태를 구현하기로 협의했습니다. 

주고 받는 보안 토큰의 형태는 보편적으로 사용하고 단순하지만 확장가능한 인증 방식이며, ==stateless==라는 장점이 있어 ==JWT==를 채택하였습니다. 

### -로그인 프로세스
&nbsp;대략적인 로그인 프로세스는 다음과 같이 구성되었습니다.
1. 프론트에서 백엔드로 로그인 요청
2. 백엔드에서 요청을 보낸 페이지를 각 소셜로그인 프로바이더(==google==, ==카카오== 등)의 로그인 페이지로 리디렉션
3. 프로바이더 로그인이 성공하면 프로바이더 측에서 백엔드로 ==Access Token==발급 (여기서의 토큰은 프론트엔드 < > 백엔드가 아닌 프로바이더 < > 백엔드가 주고받는 토큰)
4. 소셜 인증이 성공하면 프론트 측 ==callback==페이지로 리디렉션 & 브라우저에 ==Refresh Token== 세팅 (==https only 쿠키==) 
5. 직후 ==callback==페이지에서 ==Refresh Token==을 가지고 ==Access Token==(프론트엔드 < > 백엔드가 주고받는 토큰)을 발급
6. 로그인 성공 & 로그인 위치로의 리디렉션

==Access Token==과 ==Refresh Token==의 구현에 대해 알아보겠습니다. 

***

## 2. Access vs Refresh 토큰
### -차이점
&nbsp;해당 프로젝트에서는 ==Access Token==과 ==Refresh Token==을 구별하여 구현하였습니다. 둘의 차이점을 요약하면 다음과 같습니다.

|구분|Access|Refresh|
|:---:|:---:|:---:|
|유효기간|30분|30일|
|저장공간|메모리|쿠키(https only)|
|용도|인증요청시 포함|Access Token 재발급|
|보안|다소 취약(js접근 가능)|보안적 측면 유리|


요약하면 ==Access Token==은 ==js==에서 접근하여 요청을 넣을 때 직접적으로 사용하는 토큰, ==Refresh Token==은 ==Access Token==을 재발급 하기 위한 토큰이라고 보시면 될 것 같습니다.

아래에서 더 상세히 알아보겠습니다.

### -Access Token
&nbsp;앞서 설명했다시피 ==Access Token==은 인증 헤더에 포함하여 요청할 때 사용되는 토큰입니다. 이는 프로젝트 내의 모든 곳에서 사용할 수 있어야 하므로, 전역 상태로 저장할 필요성이 있었습니다.

다만 ==로컬 스토리지==나 ==세션 스토리지== 같은 경우 보안에서의 문제가 생길 경우가 있으므로, ==zustand==에서 관리하여 ==메모리==에 저장하는 방식으로 구현했습니다. 

==메모리==에 저장하는 방식은, 브라우저 세션 단위로 관리되기 때문에 페이지를 이동하면 토큰이 사라집니다. 하지만 해당 프로젝트는 ==SPA==프로젝트로 구현되어있기 때문에 더욱 적합하게 사용할 수 있었습니다. 

> /stores/authStore.ts
```ts
export const useAuthStore = create<AuthState>()(
  devtools((set) => ({
    accessToken: null,
    user: null,
    isLoggedIn: false,
    authLoading: true,

    setAuth: (accessToken, user) =>
      set({ isLoggedIn: true, accessToken, user }),
    setAuthLoading: (loading: boolean) => set({ authLoading: loading }),
    logout: () =>
      set({
        isLoggedIn: false,
        accessToken: null,
        user: null,
      }),
  }))
);
```
위의 코드와 같이 ==Access Token==을 저장하는 ==zustand== ==store==를 구축하였습니다. 

==JWT==는 크게 ==Header===, ==Payload==, ==Signature==로 구성되어있는데, 백엔드와의 협의를 통해 ==Payload==에 사용자의 닉네임과 email이 포함되게 하였습니다. 
포함된 내용은 ==jwt-decode== 패키지의 `jwtDecode`함수를 이용하여 ==decode==후 ==zustand== ==store==에 저장합니다. 사용자 정보 요청 API가 존재하였지만, 요청없이 닉네임과 email정보가 필요할 때 활용하였습니다.

>/lib/authUtils.ts
```ts
const decodeAndSetAuth = (data: any) => {
  const { setAuth } = useAuthStore.getState();
  const accessToken = data.data.accessToken; // 발급받은 accessToken
  const decoded = jwtDecode<JWTPayLoad>(accessToken); // jwt decode 작업
  const { displayName, email } = decoded;
  setAuth(accessToken, { name: displayName, email: email });
};
```

발급 & 저장된 ==Access Token==은 인증이 필요한 요청에서 다음과 같이 사용됩니다.

>/lib/fetchUtils.ts
```ts
const fetchWithAuth = async (
  endPoint: string, // 상대 경로만 받음(/api/user/logout)
  init?: RequestInit
): Promise<Response> => {
  const { logout } = useAuthStore.getState();

  const fullURL = `${import.meta.env.VITE_API_BASE_URL}${endPoint}`;

  //access토큰 기반 헤더 생성
  const addAuthHeader = (headers: HeadersInit = {}) => {
    const { accessToken } = useAuthStore.getState(); // zustand에서 최신의 토큰을 가져옴
    return accessToken
      ? { ...headers, Authorization: `Bearer ${accessToken}` } //인증헤더 리턴
      : headers;
  };

  //보안 헤더 포함해서 요청
  let res = await fetch(fullURL, {
    credentials: "include",
    ...init,
    headers: addAuthHeader(init?.headers), // 요청에 인증헤더 포함
  });
  ...
```

### -Refresh Token
&nbsp;==Access Token==은 ==js==에서 접근할 수 있는 대신, 보안을 위해 만료시간을 매우 짧게(30분) 설정하였습니다. 만료된 토큰을 재발급 하기 위해서는 브라우저에 사용자임을 인증할 수 있는 수단이 있어야 하는데, 이를 위해 사용된 것이 ==Refresh Token==입니다.

==Refresh Token==은 보안을 위해 ==https only==형식의 쿠키로 백엔드에서 설정해줍니다. 이 값은 ==js==에서 접근 할 수 없으며, 오로지 백엔드로의 api요청을 통해 발급, 제거가 가능합니다. 쿠키를 포함한 요청은

>/hooks/useIssueAccessToken.ts
```ts
const loadUserInfo = async () => {
      setAuthLoading(true);
      try {
        const res = await fetch(
          `${import.meta.env.VITE_API_BASE_URL}/api/user/reissue`,
          {
            method: "POST",
            credentials: "include", // 요청시에 쿠키를 포함하는 요청
          }
        );
        ... 
```
와 같이 `credentials: "include"`를 통해 할 수 있습니다.

또한 수명도 설정이 가능합니다. 백엔드와의 협의를 통해 요청 파라미터의 ==boolean==값으로 ==true==면 ==지속 쿠키==, ==false==면 ==세션쿠키==가 발급 되게끔 구현하였습니다.

==지속 쿠키==의 경우, 쿠키는 백엔드에서 설정한 수명(30일)을 가지게 되며, 브라우저를 닫아도 해당 쿠키는 남아있게 됩니다. 

==세션 쿠키==의 경우, 브라우저를 닫으면 해당 쿠키는 사라지게 됩니다. 

위의 두 속성을 활용하면 자동 로그인 기능을 구현할 수 있습니다. 

만약 자동로그인 일 경우, 로그인 요청시에 ==지속 쿠키==를 요구하면, 해당 쿠키는 브라우저에 계속 남아있게되고, 다시 재방문시에

>/App.tsx
```ts
import { BrowserRouter } from "react-router-dom";

import useUserLocation from "./hooks/useUserLocation";
import useIssueAccessToken from "./hooks/useIssueAccessToken";

import AppShell from "./components/layout/AppShell";

function App() {
  useUserLocation();
  useIssueAccessToken();

  return (
    <BrowserRouter>
      <AppShell />
    </BrowserRouter>
  );
}

export default App;
```
와 같이 ==Access Token==을 재발급 하는 커스텀 훅(useIssueAccessToken)을 실행하면 사용자가 브라우저를 방문 할 때 마다 ==Access Token==이 재발급 됩니다. 
> 추가로 새로고침 때 마다 재발급 요청도 가능합니다.
>> 해당 커스텀 훅은 로그인 콜백 페이지에도 위치하여 ==Access Token==을 발급 받습니다.

이후 로그아웃 시에는 ==zustand store==에 보관되어있는 ==Access Token==을 프론트엔드에서 삭제하고, 쿠키로 설정되어있는 ==Refresh Token==은 백엔드로의 삭제 요청을 통해 제거합니다. 

*** 

## 3. 마치며
&nbsp;이번 게시물에서는 ==JWT==를 기반으로 한 로그인 시스템에 대한 설명을 작성해보았습니다. 혹시 궁금한 점이나 피드백이 있으시면 댓글 남겨주세요