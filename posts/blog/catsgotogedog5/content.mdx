---
title: 어디가냥? 같이가개! 제작기 (5)
date: "2025-07-27"
desc: React 팀 프로젝트 5탄 (React Portals)
tags: ["CatsGoTogedog", "react", "portals", "DOM", "modal"]
---

## 1. 문제 발생
### -모달이 잘리는 현상
&nbsp;현재 프로젝트에는 반려동물 등록 및 수정 기능이 있습니다. 등록된 반려동물의 정보는 수정 모달을 통해 가능한데, 문제는 해당 카드를 슬라이드 하는 부모 컴포넌트에 `overflow: hidden`이라는 속성이 존재하기 때문에, 
![부모를 벗어나지 못하는 모달](/postImgs/blog/catsgotogedog5/1.png)
모달 컴포넌트가 부모 컴포넌트를 벗어나지 못하는 문제가 발생하였습니다.

모달은 배경(흐린 + 어두운색)과 윈도우(사용자가 상호작용하는 컴포넌트)로 이루어져 있는데, 배경은 `fixed`를 이용해 뷰포트 전체를 감싸고, 윈도우는 배경의 중앙에 위치하는 형식인데, 두 요소 모두 부모 컴포넌트에 가려지는 현상입니다. 

해당 문제 해결을 위해 알아보던 중 ==React Portals==라는 것을 찾아냈습니다.

***

## 2. React Portals
### -React Portals란
&nbsp;==React Portals==는 직관적인 이름과 같이, 부모 컴포넌트의 ==DOM==트리 바깥에 있는 ==DOM==노드로 자식 컴포넌트를 렌더링 할 수 있는 ==React==내장 기능입니다.
렌더링 하는 컴포넌트를 ==React== 특성 상 구축되는 ==tree==구조에서 자유로운 위치에 렌더링 할 수 있는 기능을 제공합니다.
사용법을 알아보겠습니다.

### -사용 법
&nbsp;사용 법은 간단합니다. 

>/components/modals/common/ModalPortal.tsx
```ts
import { createPortal } from "react-dom";
import { useMemo } from "react";
import type { PropsWithChildren } from "react";

const ModalPortal = ({ children }: PropsWithChildren) => {
  const container = useMemo(() => {
    let el = document.getElementById("modal-root");
    if (!el) {
      el = document.createElement("div");
      el.id = "modal-root";
      document.body.appendChild(el);
    }
    return el;
  }, []);

  return createPortal(children, container);
};

export default ModalPortal;
```

`createPortal`함수를 이용해 첫번째 인자로는 포탈 하위에 렌더링 할 컴포넌트를, 두번째 인자로는 해당 컴포넌트가 위치하게 될 노드를 넣을 수 있습니다.
저는 container라는 `div`태그를 하나 만들어 포탈안에 들어오는 컴포넌트를 렌더링할 곳을 만들었습니다.

이렇게 하고 원하는 컴포넌트를 ==Portals==의 하위에 넣어주면 됩니다. 저의 경우는 모달을 넣어주었습니다.

> /components/realMypage/myInfo/MyPetCard.tsx
```ts
{isOpen && (
  <ModalPortal>
    <MyPetEditModal
      onClose={() => setIsOpen(false)}
      petData={petData!}
    />
  </ModalPortal>
)}
```
이렇게 하면 
![스타일이 적용되지 않는 문제](/postImgs/blog/catsgotogedog5/2.png)
기존 App.css 파일에 적용한 스타일이 적용되지않는 현상이 발생합니다.

### -새로운 문제와 해결법
&nbsp;==Portals==는 ==DOM==트리 밖으로 나가기 때문에, 해당 트리에서 상속받던 ==CSS==스타일은 적용되지 않습니다. ==CSS==변수를 전역화 하는 방법도 있지만, 저는 더욱 손쉬운 방법을 선택하였습니다. 

>/components/modals/common/ModalPortal.tsx
```ts
import { createPortal } from "react-dom";
import { useMemo } from "react";
import type { PropsWithChildren } from "react";

const ModalPortal = ({ children }: PropsWithChildren) => {
  const container = useMemo(() => {
    let el = document.getElementById("modal-root");
    if (!el) {
      el = document.createElement("div");
      el.id = "modal-root";
      document.body.appendChild(el);
    }
    return el;
  }, []);

  return createPortal(children, container);
};
```
위에서 보여드린 ==Portals==입니다.
여기서 저는 ==modal-root==라는 ==id==를 가진 `div`에 모달을 위치시켰습니다. 해당 div가 현재 ==DOM==에 없기 때문에 스타일이 적용되지 않는 것이기 때문에

> /components/realMypage/myInfo/MyPetSection.tsx
```ts
import { useMyPetSection } from "@/hooks/useMyPetSection";
import MyPetSlideSection from "./MyPetSlideSection";

const MyPetSection = () => {
  const { petList } = useMyPetSection();
  return (
    <section className="w-full h-fit flex flex-col gap-[16px]">
      <h2 className="w-full h-[32px] font-semibold text-[20px]">
        반려동물 정보
      </h2>

      <MyPetSlideSection petList={petList} />
      <div id="modal-root" /> // 앵커 추가
    </section>
  );
};

export default MyPetSection;
```
위의 코드와 같이 원하는 트리 단계(이 경우 overflow: hidden이 적용되지 않는 구간)에 포탈이 위치할 ==포탈 앵커==를 넣어주기만 하면 됩니다. ==포탈 앵커==가 위치한 지점에 컴포넌트가 렌더링 되므로 스타일 적용을 받을 수 있게 됩니다.

해당 앵커를 추가하게 되면
![문제 해결](/postImgs/blog/catsgotogedog5/3.png)
위와 같이 모달이 잘리지도 않고, 스타일이 잘 적용된 것을 볼 수 있습니다.


*** 

## 3. 마치며
&nbsp;이번 게시물에서는 ==React Portals==를 통해 부모 컴포넌트 바깥의 지점에 컴포넌트를 렌더링 하는 방법에 대해 알아보았습니다. 혹시 궁금한 점이나 피드백이 있으시면 댓글 남겨주세요